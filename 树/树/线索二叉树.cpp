#include<stdio.h>
typedef int TElemType; //根结点的数据类型，此处定位整型

//二叉树的二叉线索存储结构定义
//Link==0 表示指向左右孩子指针
//Thread==1 表示指向前驱或者后继的线索
typedef enum{ Link, Thread } PointerTag;

typedef struct BiThrNode //二叉线索存储点结构
{
	TElemType data;     //结点数据
	struct BiThrNode *lchild, *rchild;   //左右孩子指针
	PointerTag LTag;  //左标志
	PointerTag RTag;  //右标志
}BiThrNode,*BiThrTree;

BiThrTree pre;  //全局变量，始终指向刚刚访问过的终点
//中序遍历进行中序线索化
void InThreading(BiThrTree p)
{
	if (p)
	{
		InThreading(p->lchild);  //递归左子树线索化
		if (!p->lchild)  //没有左孩子
		{
			p->LTag = Thread;  //前驱线索
			p->lchild = pre;   //左孩子指针指向前驱
		}
		if (!pre->rchild) //前驱没有右孩子
		{
			pre->RTag = Thread;  //后继线索
			pre->rchild = p;  //前驱右孩子指针指向后继（当前结点p）
		}
		pre = p;  //保持pre指向p的前驱
		InThreading(p->rchild);  //递归右子树线索化
	}
}

#define OK 1
#define ERROR 0
typedef int ElemType; //也就相当于给int起别名  
typedef int Status; //创建子函数返回类型 

/*
 T 指向头结点，头结点左链 lchild 指向根结点，头结点右键 rchild 指向
中序遍历的最后一个结点。中序遍历二叉树线索链表表示的二叉树 T 
*/
Status InOrderTraverse_Thr(BiThrTree T)
{
	BiThrTree p;
	p = T->lchild; // p 指向根结点
	while (p != T)
	{
		while (p->LTag == Link) //当 LTag==0 时循环到中序序列第一个结点
		{
			p = p->lchild;
		}
		printf("%c", p->data); //显示结点数据，可以更改为其他对结点操作
		while (p->RTag == Thread&&p->rchild != T)
		{
			p = p->rchild;
			printf("%c", p->data);
		}
		p = p->rchild; // p 进至其右子树根
	}
	return OK;
}
